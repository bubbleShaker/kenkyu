# これは
卒業研究に使うプログラムを置きます。デバッグの過程やメモなど適当に書いているのでかなり見にくいです。

## HyperLogLog32
32ビットのハッシュ関数を使ったHyperLogLog
## 10/12
プログラムがバグり散らかす<br>
![photo](photo/241012/p=4.png)<br>

問題点
- n>=100の時、推定カーディナリティ数が-nanとなっている。恐らく値が大きくなりすぎてオーバーフローしている。

何が原因？
- ハッシュ関数が変?<br>
そもそもn=1000000の時、種類数が999874になっているので単射ではなさそう。
- 実装ミス?

今後やりたいこと
- pの値を変更して推定値がどう変化するか見る
- 入力データの値の範囲を変更してみる
- 64ビットverのHyperLogLogも作る
- LogLogや他のカーディナリティ推定アルゴリズムも実装・理解していく

p=4の場合の結果だったので、p=10,p=16についてもそれぞれ調べてみる。

p=10の場合<br>
![photo](photo/241012/p=10.png)<br>

p=4の時と比べると、-nanが無くなった。また、n<=100についてはp=4の時と比べると実際の値と近くなった。

問題点
- n>=1000の時、推定カーディナリティ数が197.269から動かない

何が原因?
- 分からない。HELP

p=16の場合<br>
![photo](photo/241012/p=16.png)<br>

n<=100の時については、より実際の値に近づいた。

問題点
- n>=1000の時、推定カーディナリティ数が184.846から動かない

何が原因?
- 本当に分からない。

### デバッグをする

HyperLogLog32.cppの67行目でV=0に初期化するのを忘れていた。これでもう一度各pについて結果を見てみる。<br>
→変わらなかった

calc_idxでビット長を7にしていた。デバッグ用に変えた時の残骸…。<br>
→ビット長を32に変更したらマシな結果が出てきた。各pについて、改めてまとめてみる。

p=4の場合<br>
![photo](photo/241012/p=4_2.png)<br>

p=10の場合<br>
![photo](photo/241012/p=10_2.png)<br>

p=16の場合<br>
![photo](photo/241012/p=16_2.png)<br>

### -nanの原因が判明
```cpp:HyperLogLog32.cpp
else {
  E=-pow(2,32)*std::log2(1-E/std::pow(2,32));
}
```
この部分でEがpow(2,32)を超えてしまうと真数が負数になってしまい、エラーになっていることが分かった。

### 他に間違えていた箇所
Eの計算に用いるamは、mの大きさによって変える必要があったのだが、変更していなかった…。<br>
amを適切に変更した状態で、p=4から見てみる。<br>
→特に変わらなかった。

## 方向転換
Eの値によって補正するパートを一旦無視した状態でEを見てみることにした。

p=4補正無しの場合<br>
![photo](photo/241012/p=4_nhosei.png)<br>

p=10補正無しの場合<br>
![photo](photo/241012/p=10_nhosei.png)<br>

p=16補正無しの場合<br>
![photo](photo/241012/p=16_nhosei.png)<br>

## 10/16
同期の子からハッシュ関数について、HLL++とHLL-βではMD5,MURMUR,SHAを使っているので、そっちに合わせた方がよいのでは、という指摘をもらった(今現在使っているのはxorshift)。<br>
### MD5について
[【MD5って何？】なんでもう使われていないのかまとめてみた！](https://qiita.com/SDTakeuchi/items/821a32501312d5d0b13e)<br>
この記事によると、MD5は現在使われていないらしい。<br>
ハッシュ関数の3つの安全性として、<br>
- 一方向性
- 衝突困難性
- 第二現像計算困難性

がある。<br>
結論から言うと、MD5は衝突困難性が破られてしまったらしい。細かいことは上記の記事に書いてあるので…。

### murmurhashについて
[MurmurHash](https://en.wikipedia.org/wiki/MurmurHash)に色々書いてある。また、調べてみるとC++で実装したコードをGitHub上に公開している人もいた。

### SHAについて
[Secure Hash Algorithm](https://ja.wikipedia.org/wiki/Secure_Hash_Algorithm)に色々書いてある。正直よくわからない(!?)<br>
32ビット長の出力をしてほしいのだが、256ビット長以上とかしかなくない…？

### とりあえずどうする？
論文を自分であまり読めていないし、これからも読める自信がない(!?)<br>
英語が原因なのか何なのか分からないが、どうも読み進めることができなくて困っている…。<br>
ハッシュ関数の実装はとりあえずxorshitのままにしておいて、他に気になったりやりたいことがあるので、そちらを優先したい。

## 10/12の続き
補正なしでの推定カーディナリティ数を見たところ、いずれのpについても、実際の値よりかなり大きい値が出ることが分かった。<br>
ハッシュ関数を変えるとどれくらい結果に違いが出るのか気になったので、やはりMurmurHashを使ってみる。<br>
[このページ](https://github.com/aappleby/smhasher/blob/master/src/MurmurHash3.cpp)のMurmurHash3のプログラムを使わせていただく。<br>
とりあえずMurmurHash3をプログラムに組み込めたので、p=4,p=10,p=16について、補正なしと補正ありの結果の計6パターンを調べてみる。<br>

p=4補正無し<br>
![photo](photo/241016/p=4_nhosei.png)<br>

p=10補正無し<br>
![photo](photo/241016/p=10_nhosei.png)<br>

p=16補正無し<br>
![photo](photo/241016/p=16_nhosei.png)<br>

p=4補正あり<br>
![photo](photo/241016/p=4_hosei.png)<br>

p=10補正あり<br>
![photo](photo/241016/p=10_hosei.png)<br>

p=16補正あり<br>
![photo](photo/241016/p=16_hosei.png)<br>
補正なしは置いておいて、補正ありについて見てみる。<br>
例えばp=10でn=10000についてみてみると、実際の値よりも20倍近い値が出ている。普通にプログラムにバグがある気がするので見てみる。<br>


#### 以下メモ
また、現在のテストケースについては、メルセンヌ・ツイスタを用いて[0, (2^32)-1] の一様分布整数を生成している。これを正規分布とかにした結果も後々調べる。<br>
また、補正なしと補正ありの結果から分かるように、補正の効果はかなり強力だと分かる。<br>
各補正に使われているアルゴリズムのうち、LINEARCOUNTINGなど分かりやすいものを深掘りしていきたい。